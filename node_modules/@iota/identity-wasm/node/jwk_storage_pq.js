"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwkPqMemStore = void 0;
// Copyright 2024 Fondazione Links
// SPDX-License-Identifier: Apache-2.0
const ed = __importStar(require("@noble/ed25519"));
const ml_dsa_1 = require("@noble/post-quantum/ml-dsa");
const _identity_wasm_1 = require("./identity_wasm.js");
// JkwStorage for PQ and PQ/T examples
class JwkPqMemStore {
    /** The map from key identifiers to Jwks. */
    _keys;
    /** Creates a new, empty `MemStore` instance. */
    constructor() {
        this._keys = new Map();
    }
    static mldsaKeyType() {
        return "AKP";
    }
    static ed25519KeyType() {
        return "Ed25519";
    }
    _get_key(keyId) {
        return this._keys.get(keyId);
    }
    async generate(keyType, algorithm) {
        if (keyType !== JwkPqMemStore.ed25519KeyType()) {
            throw new Error(`unsupported key type ${keyType}`);
        }
        if (algorithm !== "EdDSA" /* JwsAlgorithm.EdDSA */) {
            throw new Error(`unsupported algorithm`);
        }
        const keyId = randomKeyId();
        const privKey = ed.utils.randomPrivateKey();
        const publicKey = await ed.getPublicKey(privKey);
        const jwk = await encodeJwk(privKey, publicKey, algorithm);
        this._keys.set(keyId, jwk);
        const publicJWK = jwk?.toPublic();
        if (!publicJWK) {
            throw new Error(`JWK is not a public key`);
        }
        return new _identity_wasm_1.JwkGenOutput(keyId, publicJWK);
    }
    async generatePQKey(keyType, algorithm) {
        if (keyType !== JwkPqMemStore.mldsaKeyType()) {
            throw new Error(`unsupported key type ${keyType}`);
        }
        const seed = new TextEncoder().encode(randomKeyId());
        let keys;
        if (algorithm === "ML-DSA-44" /* JwsAlgorithm.MLDSA44 */) {
            keys = ml_dsa_1.ml_dsa44.keygen(seed);
        }
        else if (algorithm === "ML-DSA-65" /* JwsAlgorithm.MLDSA65 */) {
            keys = ml_dsa_1.ml_dsa65.keygen(seed);
        }
        else if (algorithm === "ML-DSA-87" /* JwsAlgorithm.MLDSA87 */) {
            keys = ml_dsa_1.ml_dsa87.keygen(seed);
        }
        else {
            throw new Error(`unsupported algorithm`);
        }
        const keyId = randomKeyId();
        const jwk = await encodeJwk(keys.secretKey, keys.publicKey, algorithm);
        if (jwk == undefined) {
            throw new Error("Unexpected error: await encodeJwk(privKey, publicKey, algorithm)");
        }
        this._keys.set(keyId, jwk);
        const publicJWK = jwk?.toPublic();
        if (!publicJWK) {
            throw new Error(`JWK is not a public key`);
        }
        return new _identity_wasm_1.JwkGenOutput(keyId, publicJWK);
    }
    async sign(keyId, data, publicKey) {
        let alg = publicKey.alg();
        let signature = null;
        if (alg === undefined) {
            throw new Error("expected a Jwk with an `alg` parameter");
        }
        if (alg !== "EdDSA" /* JwsAlgorithm.EdDSA */) {
            throw new Error("unsupported JWS algorithm");
        }
        else {
            if (publicKey.paramsOkp()?.crv !== "Ed25519" /* EdCurve.Ed25519 */) {
                throw new Error("unsupported Okp parameter");
            }
        }
        const jwk = this._keys.get(keyId);
        if (jwk) {
            const [privateKey, _] = decodeJwk(jwk);
            signature = await ed.sign(data, privateKey);
        }
        else {
            throw new Error(`key with id ${keyId} not found`);
        }
        return signature;
    }
    async signPQ(keyId, data, publicKey, ctx) {
        let alg = publicKey.alg();
        let signature = null;
        if (alg === undefined) {
            throw new Error("expected a Jwk with an `alg` parameter");
        }
        if (alg !== "ML-DSA-44" /* JwsAlgorithm.MLDSA44 */ && alg !== "ML-DSA-65" /* JwsAlgorithm.MLDSA65 */ && alg !== "ML-DSA-87" /* JwsAlgorithm.MLDSA87 */) {
            throw new Error("unsupported JWS algorithm");
        }
        const jwk = this._keys.get(keyId);
        if (jwk) {
            const [privateKey, _] = decodeJwk(jwk);
            if (alg == "ML-DSA-44" /* JwsAlgorithm.MLDSA44 */) {
                signature = ml_dsa_1.ml_dsa44.sign(privateKey, data, ctx);
            }
            else if (alg == "ML-DSA-65" /* JwsAlgorithm.MLDSA65 */) {
                signature = ml_dsa_1.ml_dsa65.sign(privateKey, data, ctx);
            }
            else if (alg == "ML-DSA-87" /* JwsAlgorithm.MLDSA87 */) {
                signature = ml_dsa_1.ml_dsa87.sign(privateKey, data, ctx);
            }
            else {
                throw new Error("unsupported algorithm");
            }
        }
        else {
            throw new Error(`key with id ${keyId} not found`);
        }
        return signature;
    }
    async insert(jwk) {
        const keyId = randomKeyId();
        if (!jwk.isPrivate) {
            throw new Error("expected a JWK with all private key components set");
        }
        if (!jwk.alg()) {
            throw new Error("expected a Jwk with an `alg` parameter");
        }
        this._keys.set(keyId, jwk);
        return keyId;
    }
    async delete(keyId) {
        this._keys.delete(keyId);
    }
    async exists(keyId) {
        return this._keys.has(keyId);
    }
    count() {
        return this._keys.size;
    }
}
exports.JwkPqMemStore = JwkPqMemStore;
// Encodes a Ed25519 keypair into a Jwk.
async function encodeJwk(privateKey, publicKey, alg) {
    let pub = (0, _identity_wasm_1.encodeB64)(publicKey);
    let priv = (0, _identity_wasm_1.encodeB64)(privateKey);
    if (alg === "EdDSA" /* JwsAlgorithm.EdDSA */) {
        return new _identity_wasm_1.Jwk({
            "kty": "OKP" /* JwkType.Okp */,
            crv: "Ed25519",
            d: priv,
            x: pub,
            alg,
        });
    }
    else {
        return new _identity_wasm_1.Jwk({
            "kty": "AKP" /* JwkType.Akp */,
            pub: pub,
            priv: priv,
            alg,
        });
    }
}
function decodeJwk(jwk) {
    if (jwk.alg() !== "ML-DSA-44" /* JwsAlgorithm.MLDSA44 */
        && jwk.alg() !== "ML-DSA-65" /* JwsAlgorithm.MLDSA65 */
        && jwk.alg() !== "ML-DSA-87" /* JwsAlgorithm.MLDSA87 */
        && jwk.alg() !== "EdDSA" /* JwsAlgorithm.EdDSA */) {
        throw new Error("unsupported `alg`");
    }
    if (jwk.alg() === "EdDSA" /* JwsAlgorithm.EdDSA */) {
        const paramsOkp = jwk.paramsOkp();
        if (paramsOkp) {
            const d = paramsOkp.d;
            if (d) {
                const textEncoder = new TextEncoder();
                const privateKey = (0, _identity_wasm_1.decodeB64)(textEncoder.encode(d));
                const publicKey = (0, _identity_wasm_1.decodeB64)(textEncoder.encode(paramsOkp.x));
                return [privateKey, publicKey];
            }
            else {
                throw new Error("missing private key component");
            }
        }
        else {
            throw new Error("expected Okp params");
        }
    }
    else {
        const paramsPQ = jwk.paramsAkp();
        if (paramsPQ) {
            const priv = paramsPQ.priv;
            if (priv) {
                let textEncoder = new TextEncoder();
                const privateKey = (0, _identity_wasm_1.decodeB64)(textEncoder.encode(priv));
                const publicKey = (0, _identity_wasm_1.decodeB64)(textEncoder.encode(paramsPQ.pub));
                return [privateKey, publicKey];
            }
            else {
                throw new Error("missing private key component");
            }
        }
        else {
            throw new Error("expected Okp params");
        }
    }
}
// Returns a random number between `min` and `max` (inclusive).
// SAFETY NOTE: This is not cryptographically secure randomness and thus not suitable for production use.
// It suffices for our testing implementation however and avoids an external dependency.
function getRandomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
// Returns a random key id.
function randomKeyId() {
    const randomness = new Uint8Array(20);
    for (let index = 0; index < randomness.length; index++) {
        randomness[index] = getRandomNumber(0, 255);
    }
    return (0, _identity_wasm_1.encodeB64)(randomness);
}
//# sourceMappingURL=jwk_storage_pq.js.map