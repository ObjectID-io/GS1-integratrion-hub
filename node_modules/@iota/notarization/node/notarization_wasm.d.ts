/* tslint:disable */
/* eslint-disable */
/**
 * Represents the notarization method of a notarization object.
 *
 * This enum defines the possible methods for a notarization:
 * - `Dynamic`: Dynamic notarization.
 * - `Locked`: Locked notarization.
 */

type NotarizationMethod = "Dynamic" | "Locked";
/**
 * Represents the type of a time lock.
 *
 * This enum defines the possible types of time locks that can be applied to a notarization object.
 * - `None`: No time lock is applied.
 * - `UnlockAt`: The object will unlock at a specific timestamp.
 * - `UntilDestroyed`: The object remains locked until it is destroyed. Can not be used for `delete_lock`.
 */

type TimeLockType = "None" | "UnlockAt" | "UntilDestroyed";

import {
    Balance,
    ExecuteTransactionBlockParams,
    GetCoinsParams,
    GetDynamicFieldObjectParams,
    GetObjectParams,
    GetOwnedObjectsParams,
    GetTransactionBlockParams,
    IotaClient,
    IotaObjectData,
    IotaObjectResponse,
    IotaTransactionBlockResponse,
    IotaTransactionBlockResponseOptions,
    ObjectRead,
    PaginatedCoins,
    PaginatedEvents,
    PaginatedObjectsResponse,
    QueryEventsParams,
    TryGetPastObjectParams,
    DevInspectTransactionBlockParams,
    DevInspectResults
} from "@iota/iota-sdk/client";
import { bcs } from "@iota/iota-sdk/bcs";
import {
    executeTransaction,
    WasmIotaTransactionBlockResponseWrapper,
} from "./iota_client_helpers"



import {
    Transaction,
    TransactionOutput,
    TransactionBuilder,
    CoreClient,
    CoreClientReadOnly
} from './index';



import { PublicKey } from "@iota/iota-sdk/cryptography";

interface TransactionSigner {
    sign: (tx_data_bcs: Uint8Array) => Promise<string>;
    publicKey: () => Promise<PublicKey>;
    iotaPublicKeyBytes: () => Promise<Uint8Array>;
    keyId: () => string;
}



import { Request, Response } from "@iota/iota_interaction_ts/http_client";



/**
 * Represents a transaction for creating dynamic notarization's.
 *
 * Dynamic notarization's can be updated after creation, with modification capabilities
 * for both state and metadata.
 */
export class CreateNotarizationDynamic {
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Applies transaction effects and events to this notarization creation operation.
     *
     *
     * This method is called automatically by Transaction::build_programmable_transaction()
     * and Transaction::apply() methods after the transaction has been successfully submitted
     * to process the results from the ledger.
     *
     * # Arguments
     * * `effects` - The transaction block effects to apply.
     * * `events` - The transaction block events to apply.
     *
     * # Returns
     * The created notarization ID if successful.
     */
    applyWithEvents(wasm_effects: TransactionEffects, wasm_events: IotaEvent[], client: CoreClientReadOnly): Promise<OnChainNotarization>;
    /**
     * Builds and returns a programmable transaction for creating a dynamic notarization.
     *
     * # Returns
     * The binary BCS serialization of the programmable transaction.
     * This transaction can be submitted to the network to create a new dynamic notarization.
     *
     * # Errors
     * Returns an error if the transaction cannot be built due to invalid parameters
     * or other constraints.
     */
    buildProgrammableTransaction(client: CoreClientReadOnly): Promise<Uint8Array>;
    constructor(builder: NotarizationBuilderDynamic);
}

/**
 * Represents a transaction for creating locked notarization's.
 *
 * Locked notarization's cannot be modified after creation, ensuring data permanence.
 */
export class CreateNotarizationLocked {
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Applies transaction effects and events to this notarization creation operation.
     *
     * This method is called automatically by Transaction::build_programmable_transaction()
     * and Transaction::apply() methods after the transaction has been successfully submitted
     * to process the results from the ledger.
     *
     * # Arguments
     * * `effects` - The transaction block effects to apply.
     * * `events` - The transaction block events to apply.
     *
     * # Returns
     * The created notarization ID if successful.
     */
    applyWithEvents(wasm_effects: TransactionEffects, wasm_events: IotaEvent[], client: CoreClientReadOnly): Promise<OnChainNotarization>;
    /**
     * Builds and returns a programmable transaction for creating a locked notarization.
     *
     * # Returns
     * The binary BCS serialization of the programmable transaction.
     * This transaction can be submitted to the network to create a new locked notarization.
     *
     * # Errors
     * Returns an error if the transaction cannot be built due to invalid parameters
     * or other constraints.
     */
    buildProgrammableTransaction(client: CoreClientReadOnly): Promise<Uint8Array>;
    constructor(builder: NotarizationBuilderLocked);
}

/**
 * Represents the different types of data that can be notarized.
 */
export class Data {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Converts the data to a byte array.
     *
     * # Returns
     * A `Uint8Array` containing the byte representation of the data.
     */
    toBytes(): Uint8Array;
    /**
     * Converts the data to a string representation.
     *
     * # Returns
     * A `String` containing the text representation of the data.
     */
    toString(): string;
    /**
     * Retrieves the value of the data as a `any`.
     *
     * # Returns
     * A `any` containing the data, either as bytes or text.
     */
    readonly value: any;
}

/**
 * A default implementation for {@link HttpClient}.
 */
export class DefaultHttpClient {
    free(): void;
    [Symbol.dispose](): void;
    constructor();
    send(request: Request): Promise<Response>;
}

/**
 * Represents a transaction for deleting a notarization.
 */
export class DestroyNotarization {
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Applies transaction effects and events to this notarization delete operation.
     *
     * This method is called automatically by Transaction::build_programmable_transaction()
     * and Transaction::apply() methods after the transaction has been successfully submitted
     * to process the results from the ledger.
     *
     * # Arguments
     * * `effects` - The transaction block effects to apply.
     * * `events` - The transaction block events to apply.
     */
    applyWithEvents(wasm_effects: TransactionEffects, wasm_events: IotaEvent[], client: CoreClientReadOnly): Promise<Empty>;
    /**
     * Builds and returns a programmable transaction for deleting a notarization.
     *
     * # Returns
     * The binary BCS serialization of the programmable transaction.
     * This transaction can be submitted to the network to delete a notarization.
     *
     * # Errors
     * Returns an error if the transaction cannot be built due to invalid parameters
     * or other constraints.
     */
    buildProgrammableTransaction(client: CoreClientReadOnly): Promise<Uint8Array>;
    constructor(object_id: string);
}

export class Empty {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
}

export class GasStationParams {
    free(): void;
    [Symbol.dispose](): void;
    constructor(params?: GasStationParamsI | null);
    /**
     * Adds an `Authorization` header using `token` as a bearer token.
     */
    withAuthToken(token: string): GasStationParams;
    readonly gasReservationDuration: bigint;
    readonly headers: HeaderMap;
}

/**
 * Represents immutable metadata of a notarization.
 */
export class ImmutableMetadata {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Retrieves the timestamp when the notarization was created.
     *
     * # Returns
     * The timestamp as `number` value representing the seconds since the Unix epoch.
     */
    readonly createdAt: bigint;
    /**
     * Retrieves the description of the notarization.
     *
     * # Returns
     * A description `string`, if existing.
     */
    readonly description: string | undefined;
    /**
     * Retrieves the optional lock metadata for the notarization.
     *
     * # Returns
     * A `LockMetadata` instance, if existing.
     */
    readonly locking: LockMetadata | undefined;
}

/**
 * Represents the lock metadata of a notarization.
 */
export class LockMetadata {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * The delete lock configuration.
     */
    deleteLock: TimeLock;
    /**
     * The transfer lock configuration.
     */
    transferLock: TimeLock;
    /**
     * The update lock configuration.
     */
    updateLock: TimeLock;
}

/**
 * Represents a builder for constructing dynamic notarization transactions.
 *
 * Dynamic notarizations are updatable records that can evolve over time.
 */
export class NotarizationBuilderDynamic {
    private constructor();
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Creates a new dynamic notarization builder.
     */
    static dynamic(): NotarizationBuilderDynamic;
    /**
     * Finalizes the notarization builder and returns a transaction builder
     * that can be used to build and execute the final transaction on the ledger.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    finish(): TransactionBuilder<CreateNotarizationDynamic>;
    /**
     * Adds a state to the notarization using binary data.
     *
     * # Arguments
     * * `data` - Binary data representing the state.
     * * `metadata` - Optional metadata associated with the state.
     */
    withBytesState(data: Uint8Array, metadata?: string | null): NotarizationBuilderDynamic;
    /**
     * Adds an immutable description to the notarization.
     *
     * # Arguments
     * * `description` - A string describing the notarization, or null to skip.
     */
    withImmutableDescription(description?: string | null): NotarizationBuilderDynamic;
    /**
     * Adds a state to the notarization using a string.
     *
     * # Arguments
     * * `data` - String data representing the state.
     * * `metadata` - Optional metadata associated with the state.
     */
    withStringState(data: string, metadata?: string | null): NotarizationBuilderDynamic;
    /**
     * Adds a transfer lock to the notarization.
     *
     * # Arguments
     * * `lock` - A `TimeLock` specifying the transfer lock.
     */
    withTransferLock(lock: TimeLock): NotarizationBuilderDynamic;
    /**
     * Adds updatable metadata to the notarization.
     *
     * # Arguments
     * * `metadata` - A string representing the metadata, or null to skip.
     */
    withUpdatableMetadata(metadata?: string | null): NotarizationBuilderDynamic;
}

/**
 * Represents a builder for constructing locked notarization transactions.
 *
 * Locked notarizations are immutable records (the notarization state) that cannot be modified
 * after creation.
 */
export class NotarizationBuilderLocked {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Finalizes the notarization builder and returns a transaction builder
     * that can be used to build and execute the final transaction on the ledger.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    finish(): TransactionBuilder<CreateNotarizationLocked>;
    /**
     * Creates a new locked notarization builder.
     */
    static locked(): NotarizationBuilderLocked;
    /**
     * Adds a state to the notarization using binary data.
     *
     * # Arguments
     * * `data` - Binary data representing the state.
     * * `metadata` - Optional metadata associated with the state.
     */
    withBytesState(data: Uint8Array, metadata?: string | null): NotarizationBuilderLocked;
    /**
     * Adds a delete lock to the notarization.
     *
     * # Arguments
     * * `lock` - A `TimeLock` specifying the delete lock.
     */
    withDeleteLock(lock: TimeLock): NotarizationBuilderLocked;
    /**
     * Adds an immutable description to the notarization.
     *
     * # Arguments
     * * `description` - A string describing the notarization, or null to skip.
     */
    withImmutableDescription(description?: string | null): NotarizationBuilderLocked;
    /**
     * Adds a state to the notarization using a string.
     *
     * # Arguments
     * * `data` - String data representing the state.
     * * `metadata` - Optional metadata associated with the state.
     */
    withStringState(data: string, metadata?: string | null): NotarizationBuilderLocked;
    /**
     * Adds updatable metadata to the notarization.
     *
     * # Arguments
     * * `metadata` - A string representing the metadata, or null to skip.
     */
    withUpdatableMetadata(metadata?: string | null): NotarizationBuilderLocked;
}

/**
 * A client to interact with Notarization objects on the IOTA ledger.
 *
 * This client is used for read and write operations. For read-only capabilities,
 * you can use {@link NotarizationClientReadOnly}, which does not require an account or signing capabilities.
 */
export class NotarizationClient {
    private constructor();
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Creates a new notarization client.
     *
     * # Arguments
     * * `client` - A read-only notarization client.
     * * `signer` - A transaction signer for signing operations.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    static create(client: NotarizationClientReadOnly, signer: TransactionSigner): Promise<NotarizationClient>;
    /**
     * Creates a notarization builder which can be used to create a dynamic notarization.
     *
     * # Returns
     * A `NotarizationBuilderDynamic` instance.
     */
    createDynamic(): NotarizationBuilderDynamic;
    /**
     * Creates a notarization builder which can be used to create a locked notarization.
     *
     * # Returns
     * A `NotarizationBuilderLocked` instance.
     */
    createLocked(): NotarizationBuilderLocked;
    /**
     * Creates a transaction to destroy a notarization object on the ledger.
     *
     * # Arguments
     * * `notarization_id` - The ID of the notarization object to destroy.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    destroy(notarization_id: string): TransactionBuilder;
    /**
     * Retrieves the IOTA client instance.
     *
     * # Returns
     * The `IotaClient` instance.
     */
    iotaClient(): IotaClient;
    /**
     * Retrieves the network identifier.
     *
     * # Returns
     * The network identifier as a `string`.
     */
    network(): string;
    /**
     * Retrieves the package history.
     *
     * # Returns
     * An `Array<string>` containing the package history.
     */
    packageHistory(): string[];
    /**
     * Retrieves the package ID.
     *
     * # Returns
     * The package ID as a `string`.
     */
    packageId(): string;
    /**
     * Retrieves a read-only version of the notarization client.
     *
     * # Returns
     * A `NotarizationClientReadOnly` instance.
     */
    readOnly(): NotarizationClientReadOnly;
    /**
     * Retrieves the sender's address.
     *
     * # Returns
     * The sender's address as an `IotaAddress`.
     */
    senderAddress(): string;
    /**
     * Retrieves the sender's public key.
     *
     * # Returns
     * The sender's public key as `PublicKey`.
     */
    senderPublicKey(): PublicKey;
    /**
     * Retrieves the transaction signer.
     *
     * # Returns
     * The `TransactionSigner` instance.
     */
    signer(): TransactionSigner;
    /**
     * Creates a transaction to transfer a notarization object to a new owner.
     *
     * # Arguments
     * * `notarization_id` - The ID of the notarization object to transfer.
     * * `recipient` - The recipient's IOTA address.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    transferNotarization(notarization_id: string, recipient: string): TransactionBuilder;
    /**
     * Creates a transaction to update the metadata of a notarization.
     *
     * **Important**: The `updatableMetadata` can only be updated depending on the used
     * `NotarizationMethod`:
     * - Dynamic: Can be updated anytime after notarization creation
     * - Locked: Immutable after notarization creation
     *
     * NOTE:
     * - does not affect the `stateVersionCount` or the `lastStateChangeAt` timestamp
     * - will fail if the notarization uses the `NotarizationMethod::Locked`
     * - Only the `updatableMetadata` can be changed; the `immutableMetadata::description` remains fixed
     * # Arguments
     * * `metadata` - The new metadata to update (optional).
     * * `notarization_id` - The ID of the notarization object.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    updateMetadata(metadata: string | null | undefined, notarization_id: string): TransactionBuilder;
    /**
     * Creates a transaction to update the `state` of a notarization.
     *
     * **Important**: The `state` can only  be updated depending on the used `NotarizationMethod`:
     * - Dynamic: Can be updated anytime after notarization creation
     * - Locked: Immutable after notarization creation
     *
     * Using this function will:
     * - set the `state` to the `new_state`
     * - increase the `stateVersionCount` by 1
     * - set the `lastStateChangeAt` timestamp to the current clock  timestamp in milliseconds
     * - emits a `NotarizationUpdated` Move event in case of success
     * - fail if the notarization uses `NotarizationMethod` `Locked`
     *
     * # Arguments
     * * `new_state` - The new state to replace the current one.
     * * `notarization_id` - The ID of the notarization object.
     *
     * # Returns
     * A `TransactionBuilder` to build and execute the transaction.
     */
    updateState(new_state: State, notarization_id: string): TransactionBuilder;
}

/**
 * A client to interact with Notarization objects on the IOTA ledger.
 *
 * This client is used for read-only operations, meaning it does not require an account
 * or signing capabilities. For write operations, use {@link NotarizationClient}.
 */
export class NotarizationClientReadOnly {
    private constructor();
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Retrieves the chain ID associated with this client.
     *
     * # Returns
     * A string representing the chain ID.
     */
    chainId(): string;
    /**
     * Creates a new instance of `otarizationClientReadOnly`.
     *
     * # Arguments
     * * `iota_client` - The IOTA client used for interacting with the ledger.
     *
     * # Returns
     * A new `NotarizationClientReadOnly` instance.
     */
    static create(iota_client: IotaClient): Promise<NotarizationClientReadOnly>;
    /**
     * Creates a new instance of `NotarizationClientReadOnly` using a specific package ID.
     *
     * # Arguments
     * * `iota_client` - The IOTA client used for interacting with the ledger.
     * * `iota_notarization_pkg_id` - The notarization package ID.
     *
     * # Returns
     * A new `NotarizationClientReadOnly` instance.
     */
    static createWithPkgId(iota_client: IotaClient, iota_notarization_pkg_id: string): Promise<NotarizationClientReadOnly>;
    /**
     * Retrieves the creation timestamp for a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of the notarization object.
     *
     * # Returns
     * The timestamp as `number` value representing the seconds since the Unix epoch.
     */
    createdAtTs(notarized_object_id: string): Promise<bigint>;
    /**
     * Retrieves the description of a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * A description string, if existing.
     */
    description(notarized_object_id: string): Promise<string | undefined>;
    /**
     * Retrieves the [`OnChainNotarization`] of a notarized object.
     *
     * This method returns the on-chain notarization object for the given object ID.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of the notarization object.
     *
     * # Returns
     * The [`OnChainNotarization`] object for the given object ID.
     */
    getNotarizationById(notarized_object_id: string): Promise<OnChainNotarization>;
    /**
     * Retrieves the underlying IOTA client used by this client.
     *
     * # Returns
     * The `IotaClient` instance.
     */
    iotaClient(): IotaClient;
    /**
     * Checks if destruction is allowed for a notarization object.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * A boolean indicating whether destruction is allowed.
     * False means that destroying is not allowed.
     */
    isDestroyAllowed(notarized_object_id: string): Promise<boolean>;
    /**
     * Checks if transferring a notarization object is allowed.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * A boolean indicating whether transfers are locked.
     * False means that transferring is allowed.
     */
    isTransferLocked(notarized_object_id: string): Promise<boolean>;
    /**
     * Checks if updates are locked for a notarization object.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * A boolean indicating whether updates are locked.
     * False means that updates are allowed.
     */
    isUpdateLocked(notarized_object_id: string): Promise<boolean>;
    /**
     * Retrieves the timestamp of the last state change for a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of the notarization object.
     *
     * # Returns
     * The timestamp as `number` value representing the seconds since the Unix epoch.
     */
    lastStateChangeTs(notarized_object_id: string): Promise<bigint>;
    /**
     * Retrieves the lock metadata of a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * The `LockMetadata`, if existing.
     */
    lockMetadata(notarized_object_id: string): Promise<LockMetadata | undefined>;
    /**
     * Retrieves the network identifier associated with this client.
     *
     * # Returns
     * A string representing the network identifier.
     */
    network(): string;
    /**
     * Retrieves the notarization method of a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * The `NotarizationMethod`.
     */
    notarizationMethod(notarized_object_id: string): Promise<NotarizationMethod>;
    /**
     * Retrieves the history of notarization package IDs.
     *
     * # Returns
     * An array of strings representing the package history.
     */
    packageHistory(): string[];
    /**
     * Retrieves the package ID of the used notarization package.
     *
     * # Returns
     * A string representing the package ID.
     */
    packageId(): string;
    /**
     * Retrieves the state of a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * The notarization `State`.
     */
    state(notarized_object_id: string): Promise<State>;
    /**
     * Retrieves the count of state versions for a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * Count as `number` value.
     */
    stateVersionCount(notarized_object_id: string): Promise<bigint>;
    /**
     * Retrieves the updatable metadata of a notarization.
     *
     * # Arguments
     * * `notarized_object_id` - The ID of a notarization object.
     *
     * # Returns
     * A metadata string, if existing.
     */
    updatableMetadata(notarized_object_id: string): Promise<string | undefined>;
}

/**
 * A builder for creating IOTA Resource Locators (IRLs) pointing within a notarization.
 */
export class NotarizationResourceBuilder {
    private constructor();
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Returns an IRL referencing this {@link OnChainNotarization} state's data.
     */
    data(): string;
    /**
     * Returns an IRL referencing this {@link OnChainNotarization}'s immutable metadata.
     */
    immutableMetadata(): string;
    /**
     * Returns an IRL referencing this {@link OnChainNotarization}'s owner.
     */
    owner(): string;
    /**
     * Returns an IRL referencing this {@link OnChainNotarization} state's metadata.
     */
    stateMetadata(): string;
    /**
     * Returns an IRL referencing this {@link OnChainNotarization}'s updatable metadata.
     */
    updatableMetadata(): string;
}

/**
 * Represents an on-chain notarization object.
 *
 * Provides access to various properties of the notarization, such as its ID, state, metadata
 * and method.
 */
export class OnChainNotarization {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Returns an IOTA Resource Locator (IRL) to the data stored within
     * this notarization object.
     *
     * The returned IRL will be in the form:
     * `iota:<network alias or genesis digest>/<notarization ID>/state/data`.
     * # Errors
     * Throws an error if the given `network` string is not a valid IOTA
     * network identifier.
     */
    iotaResourceLocatorBuilder(network: string): NotarizationResourceBuilder;
    /**
     * Retrieves the ID of the notarization.
     *
     * # Returns
     * A hexadecimal string representing the notarization ID.
     */
    readonly id: string;
    /**
     * Retrieves the immutable metadata of the notarization.
     *
     * NOTE:
     * - provides immutable information, assertions and guaranties for third parties
     * - `immutableMetadata` are automatically created at creation time and cannot be updated thereafter
     *
     * # Returns
     * An `ImmutableMetadata` object containing the metadata.
     */
    readonly immutableMetadata: ImmutableMetadata;
    /**
     * Retrieves the timestamp of the last state change.
     *
     * # Returns
     * A `number` value representing the timestamp,
     * the time in milliseconds since UNIX epoch.
     */
    readonly lastStateChangeAt: bigint;
    /**
     * Retrieves the notarization method.
     *
     * # Returns
     * A `NotarizationMethod` object representing the method.
     */
    readonly method: NotarizationMethod;
    /**
     * Retrieves the owner address of the notarization.
     *
     * # Returns
     * An `IotaAddress` object representing the owner address.
     */
    readonly owner: string;
    /**
     * Retrieves the current `state` of the notarization.
     *
     * The `state` of a notarization contains the notarized data and metadata associated with
     * the current version of the `state`.
     *
     * `state` can be updated depending on the used `NotarizationMethod`:
     * - Dynamic: Can be updated anytime after notarization creation
     * - Locked: Immutable after notarization creation
     *
     * Use `NotarizationClient::updateState()` for `state` updates.
     *
     * # Returns
     * A `State` object representing the notarization state.
     */
    readonly state: State;
    /**
     * Retrieves the count of state versions.
     *
     * # Returns
     * A `number` value representing the number of state versions.
     */
    readonly stateVersionCount: bigint;
    /**
     * Retrieves the updatable metadata of the notarization.
     *
     * Provides context or additional information for third parties
     *
     * `updatableMetadata` can be updated depending on the used `NotarizationMethod`:
     * - Dynamic: Can be updated anytime after notarization creation
     * - Locked: Immutable after notarization creation
     *
     * NOTE:
     * - `updatableMetadata` can be updated independently of `state`
     * - Updating `updatableMetadata` does not increase the `stateVersionCount`
     * - Updating `updatableMetadata` does not change the `lastStateChangeAt` timestamp
     * - Use `NotarizationClient::updateMetadata()` for `updatableMetadata` updates.
     *
     * # Returns
     * An optional string containing the metadata.
     */
    readonly updatableMetadata: string | undefined;
}

/**
 * Represents the state of a notarization.
 *
 * State encapsulates the data being notarized along with optional metadata.
 * It serves as the primary content container for both locked and dynamic
 * notarizations.
 *
 * The notarization `State` can be updated by the owner depending on the used `NotarizationMethod`:
 * - Dynamic: `data` and `metadata` of the `State` can be updated anytime after creation
 * - Locked: The `State` is immutable after notarization creation
 *
 * `State` `data` and `metadata` can only be updated at once, using method `NotarizationClient::updateState()`
 * which will increase the `stateVersionCount` and update the `lastStateChangeAt`
 * timestamp of the notarization even if only the `metadata` are altered.
 */
export class State {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Creates a new state from raw bytes.
     *
     * Use this for binary data like files, images, or serialized content.
     *
     * # Arguments
     * * `data` - The byte array data for the state.
     * * `metadata` - Optional metadata for the state.
     *
     * # Returns
     * A new `State` instance.
     */
    static fromBytes(data: Uint8Array, metadata?: string | null): State;
    /**
     * Creates a new state from a string.
     *
     * Use this for text data like documents, JSON, or configuration.
     *
     * # Arguments
     * * `data` - The string data for the state.
     * * `metadata` - Optional metadata for the state.
     *
     * # Returns
     * A new `State` instance.
     */
    static fromString(data: string, metadata?: string | null): State;
    /**
     * Retrieves the data associated with the state.
     *
     * # Returns
     * A `Data` instance containing the state data.
     */
    readonly data: Data;
    /**
     * Retrieves the metadata associated with the state.
     *
     * # Returns
     * A `string` containing the metadata, if existing.
     */
    readonly metadata: string | undefined;
}

/**
 * Represents a time lock configuration.
 *
 * It allows the creation and inspection of time lock configurations for notarization objects.
 */
export class TimeLock {
    private constructor();
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Creates a time lock with no restrictions.
     *
     * # Returns
     * A new `TimeLock` instance with no time lock applied.
     */
    static withNone(): TimeLock;
    /**
     * Creates a time lock that unlocks at a specific timestamp.
     *
     * # Arguments
     * * `time` - The timestamp in seconds since the Unix epoch at which the object will unlock.
     *
     * # Returns
     * A new `TimeLock` instance configured to unlock at the specified timestamp.
     */
    static withUnlockAt(time: number): TimeLock;
    /**
     * Creates a time lock that remains locked until the object is destroyed.
     *
     * # Returns
     * A new `TimeLock` instance configured to remain locked until destruction.
     */
    static withUntilDestroyed(): TimeLock;
    /**
     * Retrieves the arguments associated with the time lock.
     *
     * # Returns
     * An `any` value containing the arguments for the time lock:
     * - For `UnlockAt`, the timestamp is returned.
     * - For other types, `undefined` is returned.
     */
    readonly args: any;
    /**
     * Retrieves the type of the time lock.
     *
     * # Returns
     * The `TimeLockType` representing the type of the time lock.
     */
    readonly type: TimeLockType;
}

/**
 * Represents a transaction for transferring a dynamic notarization to a new owner.
 *
 * This is only available for dynamic notarization's
 */
export class TransferNotarization {
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Applies transaction effects and events to this transfer operation.
     *
     * This method is called automatically by Transaction::build_programmable_transaction()
     * and Transaction::apply() methods after the transaction has been successfully submitted
     * to process the results from the ledger.
     *
     * # Arguments
     * * `effects` - The transaction block effects to apply.
     * * `events` - The transaction block events to apply.
     */
    applyWithEvents(wasm_effects: TransactionEffects, wasm_events: IotaEvent[], client: CoreClientReadOnly): Promise<Empty>;
    /**
     * Builds and returns a programmable transaction for transferring a notarization.
     *
     * # Returns
     * The binary BCS serialization of the programmable transaction.
     * This transaction can be submitted to the network to transfer a notarization.
     *
     * # Errors
     * Returns an error if the transaction cannot be built due to invalid parameters
     * or other constraints.
     */
    buildProgrammableTransaction(client: CoreClientReadOnly): Promise<Uint8Array>;
    constructor(recipient: string, object_id: string);
}

/**
 * Represents a transaction for updating the metadata of a notarization.
 */
export class UpdateMetadata {
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Applies transaction effects and events to this metadata update operation.
     *
     * This method is called automatically by Transaction::build_programmable_transaction()
     * and Transaction::apply() methods after the transaction has been successfully submitted
     * to process the results from the ledger.
     *
     * # Arguments
     * * `effects` - The transaction block effects to apply.
     * * `events` - The transaction block events to apply.
     */
    applyWithEvents(wasm_effects: TransactionEffects, wasm_events: IotaEvent[], client: CoreClientReadOnly): Promise<Empty>;
    /**
     * Builds and returns a programmable transaction for updating the metadata of a notarization.
     *
     * # Returns
     * The binary BCS serialization of the programmable transaction.
     * This transaction can be submitted to the network to update the metadata of a notarization.
     *
     * # Errors
     * Returns an error if the transaction cannot be built due to invalid parameters
     * or other constraints.
     */
    buildProgrammableTransaction(client: CoreClientReadOnly): Promise<Uint8Array>;
    constructor(metadata: string | null | undefined, object_id: string);
}

/**
 * Represents a transaction for updating the state of a dynamic notarization.
 *
 * This is only available for dynamic notarization's
 */
export class UpdateState {
    /**
     ** Return copy of self without private attributes.
     */
    toJSON(): Object;
    /**
     * Return stringified version of self.
     */
    toString(): string;
    free(): void;
    [Symbol.dispose](): void;
    /**
     * Applies transaction effects and events to this state update operation.
     *
     * This method is called automatically by Transaction::build_programmable_transaction()
     * and Transaction::apply() methods after the transaction has been successfully submitted
     * to process the results from the ledger.
     *
     * # Arguments
     * * `effects` - The transaction block effects to apply.
     * * `events` - The transaction block events to apply.
     */
    applyWithEvents(wasm_effects: TransactionEffects, wasm_events: IotaEvent[], client: CoreClientReadOnly): Promise<Empty>;
    /**
     * Builds and returns a programmable transaction for updating the state of a notarization.
     *
     * # Returns
     * The binary BCS serialization of the programmable transaction.
     * This transaction can be submitted to the network to updating the state of a notarization.
     *
     * # Errors
     * Returns an error if the transaction cannot be built due to invalid parameters
     * or other constraints.
     */
    buildProgrammableTransaction(client: CoreClientReadOnly): Promise<Uint8Array>;
    constructor(state: State, object_id: string);
}

export class WasmManagedCoreClient {
    private constructor();
    free(): void;
    [Symbol.dispose](): void;
    iotaClient(): IotaClient;
    network(): string;
    packageHistory(): string[];
    packageId(): string;
    senderAddress(): string;
    senderPublicKey(): PublicKey;
    signer(): TransactionSigner;
}

export class WasmManagedCoreClientReadOnly {
    private constructor();
    free(): void;
    [Symbol.dispose](): void;
    iotaClient(): IotaClient;
    network(): string;
    packageHistory(): string[];
    packageId(): string;
}

/**
 * Initializes the console error panic hook for better error messages
 */
export function start(): void;
